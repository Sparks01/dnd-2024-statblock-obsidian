/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DnD2024StatblockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DnD2024StatblockPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // Add this property at the class level
    this.longStatKeys = [
      "damage resistances",
      "damage immunities",
      "condition immunities",
      "proficiency bonus",
      "challenge",
      "senses"
    ];
  }
  async onload() {
    console.log("Loading D&D 2024 Statblock Plugin");
    this.loadFonts();
    this.registerMarkdownCodeBlockProcessor("monster", this.processMonsterBlock.bind(this));
    this.registerMarkdownCodeBlockProcessor("monsterwide", async (source, el) => {
      console.log("Processing monsterwide block");
      const container = document.createElement("div");
      container.className = "monster-container monster-container-wide";
      await this.renderMonsterContent(source, container, { wide: true });
      el.appendChild(container);
    });
    this.registerMarkdownPostProcessor(this.processInlineMonsters.bind(this));
  }
  onunload() {
    console.log("Unloading D&D 2024 Statblock Plugin");
  }
  // 1. First, update your loadFonts() method to include Scaly Sans Caps
  async loadFonts() {
    try {
      const fs = require("fs");
      const path = require("path");
      const pluginPath = this.app.vault.adapter.basePath + "/.obsidian/plugins/" + this.manifest.id;
      console.log("Attempting to load fonts from:", pluginPath + "/fonts/");
      const loadFont = (fontPath, fontType) => {
        try {
          const fontData = fs.readFileSync(path.join(pluginPath, "fonts", fontPath));
          const base64Font = fontData.toString("base64");
          return `data:font/${fontType};base64,${base64Font}`;
        } catch (error) {
          console.error(`Failed to load font ${fontPath}:`, error);
          return null;
        }
      };
      const scalySansRegular = loadFont("Scaly Sans.otf", "opentype");
      const scalySansBold = loadFont("Scaly Sans Bold.otf", "opentype");
      const scalySansItalic = loadFont("Scaly Sans Italic.otf", "opentype");
      const scalySansBoldItalic = loadFont("Scaly Sans Bold Italic.otf", "opentype");
      const scalySansCaps = loadFont("Scaly Sans Caps.woff2", "opentype");
      const mrsEaves = loadFont("MrsEavesSmallCaps.ttf", "truetype");
      const fontStyle = document.createElement("style");
      fontStyle.id = "dnd-2024-fonts";
      fontStyle.textContent = `
      @font-face {
        font-family: "MrsEavesSmallCaps";
        src: ${mrsEaves ? `url("${mrsEaves}") format("truetype")` : ""};
        font-display: swap;
      }
      
      @font-face {
        font-family: "ScalySansCaps";
        src: ${scalySansCaps ? `url("${scalySansCaps}") format("opentype")` : ""};
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      
      @font-face {
        font-family: "ScalySans";
        src: ${scalySansRegular ? `url("${scalySansRegular}") format("opentype")` : ""};
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      
      @font-face {
        font-family: "ScalySans";
        src: ${scalySansBold ? `url("${scalySansBold}") format("opentype")` : ""};
        font-weight: bold;
        font-style: normal;
        font-display: swap;
      }
      
      @font-face {
        font-family: "ScalySans";
        src: ${scalySansItalic ? `url("${scalySansItalic}") format("opentype")` : ""};
        font-weight: normal;
        font-style: italic;
        font-display: swap;
      }
      
      @font-face {
        font-family: "ScalySans";
        src: ${scalySansBoldItalic ? `url("${scalySansBoldItalic}") format("opentype")` : ""};
        font-weight: bold;
        font-style: italic;
        font-display: swap;
      }
    `;
      const existingStyle = document.getElementById("dnd-2024-fonts");
      if (existingStyle) {
        existingStyle.remove();
      }
      document.head.appendChild(fontStyle);
      console.log("D&D 2024 Statblock fonts loaded via data URLs");
    } catch (error) {
      console.error("Error loading fonts:", error);
      const fallbackStyle = document.createElement("style");
      fallbackStyle.id = "dnd-2024-fonts-fallback";
      fallbackStyle.textContent = `
      .monster-container {
        font-family: Georgia, "Times New Roman", serif !important;
      }
      
      .monster-title {
        font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif !important;
      }
    `;
      document.head.appendChild(fallbackStyle);
      console.log("Using fallback fonts due to error loading custom fonts");
    }
  }
  /**
   * Extract format options from the code block parameters or inline syntax
   * @param source - Source string which may contain format options
   * @returns Object with format options like { wide: boolean }
   */
  extractFormatOptions(source) {
    const options = {
      wide: false
    };
    if (source.startsWith("wide") || source.includes("\nwide")) {
      options.wide = true;
      source = source.replace(/^wide\s*/, "").replace(/\nwide\s*/, "\n");
    }
    if (source.includes("{{monster,frame,wide") || source.includes("{!monster,frame,wide")) {
      options.wide = true;
    }
    return options;
  }
  /**
   * Process a code block with the monster language
   */
  async processMonsterBlock(source, el) {
    try {
      console.log("Processing monster code block");
      const formatOptions = this.extractFormatOptions(source);
      const container = document.createElement("div");
      container.className = "monster-container";
      if (formatOptions.wide) {
        container.classList.add("monster-container-wide");
      }
      await this.renderMonsterContent(source, container, formatOptions);
      el.appendChild(container);
    } catch (error) {
      console.error("Error processing monster block:", error);
      el.createEl("div", { text: "Error processing monster statblock: " + error.message });
    }
  }
  /**
   * Process Homebrewery style inline monster blocks
   */
  async processInlineMonsters(el, ctx) {
    try {
      if (el.closest("pre"))
        return;
      const textNodes = this.getTextNodes(el);
      for (const node of textNodes) {
        const text = node.textContent || "";
        const widePattern = /\{\{monster,frame,wide|\{!monster,frame,wide/;
        const standardPattern = /\{\{monster,frame|\{!monster,frame/;
        if (text.match(widePattern) || text.match(standardPattern)) {
          const isWide = text.match(widePattern) !== null;
          let startTag = isWide ? text.includes("{!monster,frame,wide") ? "{!monster,frame,wide" : "{{monster,frame,wide" : text.includes("{!monster,frame") ? "{!monster,frame" : "{{monster,frame";
          const startIndex = text.indexOf(startTag);
          const endIndex = text.indexOf("}}", startIndex);
          if (startIndex >= 0 && endIndex > startIndex) {
            const monsterContent = text.substring(startIndex + startTag.length, endIndex);
            const beforeText = document.createTextNode(text.substring(0, startIndex));
            const afterText = document.createTextNode(text.substring(endIndex + 2));
            const monsterContainer = document.createElement("div");
            monsterContainer.className = "monster-container";
            if (isWide) {
              monsterContainer.classList.add("monster-container-wide");
            }
            await this.renderMonsterContent(monsterContent, monsterContainer, { wide: isWide });
            const parent = node.parentNode;
            if (parent) {
              parent.insertBefore(beforeText, node);
              parent.insertBefore(monsterContainer, node);
              parent.insertBefore(afterText, node);
              parent.removeChild(node);
            }
          }
        }
      }
    } catch (error) {
      console.error("Error processing inline monsters:", error);
    }
  }
  /**
   * Get all text nodes in an element
   */
  getTextNodes(el) {
    const textNodes = [];
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    return textNodes;
  }
  /**
   * Enhanced section distribution for wide format with better column balancing
   */
  distributeSectionsForWideFormat(sections, leftColumn, rightColumn) {
    if (sections.length === 0)
      return;
    const traitsPattern = /^traits$/i;
    const actionsPattern = /^actions$/i;
    const legendaryActionsPattern = /^legendary actions$/i;
    const reactionsPattern = /^reactions$/i;
    let leftSections = [];
    let rightSections = [];
    sections.forEach((section) => {
      const title = section.title.toLowerCase();
      if (traitsPattern.test(title)) {
        leftSections.unshift(section);
      } else if (actionsPattern.test(title) || legendaryActionsPattern.test(title)) {
        rightSections.push(section);
      } else if (reactionsPattern.test(title)) {
        rightSections.push(section);
      } else {
        leftSections.push(section);
      }
    });
    const originalOrder = sections.map((s) => s.title);
    leftSections.sort((a, b) => {
      if (traitsPattern.test(a.title.toLowerCase()))
        return -1;
      if (traitsPattern.test(b.title.toLowerCase()))
        return 1;
      return originalOrder.indexOf(a.title) - originalOrder.indexOf(b.title);
    });
    rightSections.sort((a, b) => {
      if (actionsPattern.test(a.title.toLowerCase()))
        return -1;
      if (actionsPattern.test(b.title.toLowerCase()))
        return 1;
      if (legendaryActionsPattern.test(a.title.toLowerCase()))
        return 1;
      if (legendaryActionsPattern.test(b.title.toLowerCase()))
        return -1;
      return originalOrder.indexOf(a.title) - originalOrder.indexOf(b.title);
    });
    this.renderSectionsToColumn(leftSections, leftColumn);
    this.renderSectionsToColumn(rightSections, rightColumn);
  }
  /**
   * Helper method to determine section category
   */
  getSectionCategory(title, categories) {
    const lowercaseTitle = title.toLowerCase();
    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some((keyword) => lowercaseTitle.includes(keyword))) {
        return category;
      }
    }
    return "misc";
  }
  /**
   * Helper method to calculate total content length
   */
  sumContentLength(sections) {
    return sections.reduce((sum, section) => sum + section.length, 0);
  }
  /**
   * Helper method to render sections to a column
   */
  async renderSectionsToColumn(sections, column) {
    for (const section of sections) {
      const sectionEl = document.createElement("div");
      sectionEl.className = "monster-section";
      const sectionTitleEl = document.createElement("h3");
      sectionTitleEl.className = "monster-section-title";
      sectionTitleEl.textContent = section.title;
      sectionEl.appendChild(sectionTitleEl);
      const sectionContentEl = document.createElement("div");
      await import_obsidian.MarkdownRenderer.renderMarkdown(
        section.content,
        sectionContentEl,
        "",
        this
      );
      sectionEl.appendChild(sectionContentEl);
      column.appendChild(sectionEl);
    }
  }
  /**
   * Process table data for wide format (2x3 ability score grid)
   * Fixed version to ensure proper alignment
   */
  processTableDataForWideFormat(tableContent, container) {
    try {
      console.log("Processing table data for wide format");
      container.innerHTML = "";
      const tables = tableContent.split("\n\n").filter((table) => table.trim());
      console.log("Found tables:", tables.length);
      const abilityScores = {};
      tables.forEach((tableText) => {
        const rows = tableText.split("\n").filter((row) => row.trim());
        if (rows.length < 3)
          return;
        const dataRows = rows.slice(2);
        dataRows.forEach((row) => {
          const match = row.match(/\|(Str|Dex|Con|Int|Wis|Cha)\|/i);
          if (match) {
            const abilityName = match[1].toLowerCase();
            abilityScores[abilityName] = row;
            console.log(`Found ${abilityName} row:`, row);
          }
        });
      });
      console.log("Found ability scores:", Object.keys(abilityScores));
      const firstTable = tables[0];
      const firstTableRows = firstTable.split("\n").filter((row) => row.trim());
      const headerRow = firstTableRows[0];
      const headers = headerRow.split("|").filter((_, idx, arr) => idx > 0 && idx < arr.length - 1).map((cell) => cell.trim());
      const leftTableRows = [];
      if (abilityScores["str"])
        leftTableRows.push(abilityScores["str"]);
      if (abilityScores["dex"])
        leftTableRows.push(abilityScores["dex"]);
      if (abilityScores["con"])
        leftTableRows.push(abilityScores["con"]);
      const rightTableRows = [];
      if (abilityScores["int"])
        rightTableRows.push(abilityScores["int"]);
      if (abilityScores["wis"])
        rightTableRows.push(abilityScores["wis"]);
      if (abilityScores["cha"])
        rightTableRows.push(abilityScores["cha"]);
      const leftTableContainer = document.createElement("div");
      leftTableContainer.className = "ability-table-container";
      const rightTableContainer = document.createElement("div");
      rightTableContainer.className = "ability-table-container";
      const leftTable = this.createAbilityTableFromRows(headers, leftTableRows);
      const rightTable = this.createAbilityTableFromRows(headers, rightTableRows);
      leftTableContainer.appendChild(leftTable);
      rightTableContainer.appendChild(rightTable);
      container.appendChild(leftTableContainer);
      container.appendChild(rightTableContainer);
    } catch (error) {
      console.error("Error processing table data for wide format:", error);
      const errorEl = document.createElement("div");
      errorEl.textContent = "Error processing ability score tables: " + error.message;
      errorEl.style.color = "red";
      container.appendChild(errorEl);
    }
  }
  /**
   * Create an ability table from raw markdown table rows with better alignment
   * @param headers - Array of header strings
   * @param rowTexts - Array of raw markdown table rows
   * @returns HTMLTableElement with formatted ability scores
   */
  createAbilityTableFromRows(headers, rowTexts) {
    const table = document.createElement("table");
    table.className = "ability-table";
    const colgroup = document.createElement("colgroup");
    headers.forEach((_, index) => {
      const col = document.createElement("col");
      if (index === 0) {
        col.style.width = "45px";
      } else if (index === 1) {
        col.style.width = "30px";
      } else {
        col.style.width = "30px";
      }
      colgroup.appendChild(col);
    });
    table.appendChild(colgroup);
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    for (const header of headers) {
      const th = document.createElement("th");
      th.textContent = header;
      headerRow.appendChild(th);
    }
    thead.appendChild(headerRow);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    for (const rowText of rowTexts) {
      const tr = document.createElement("tr");
      const cells = rowText.split("|").filter((_, idx, arr) => idx > 0 && idx < arr.length - 1).map((cell) => cell.trim());
      for (let j = 0; j < cells.length; j++) {
        const td = document.createElement("td");
        if (j === 0) {
          td.className = "ability-name";
        }
        td.textContent = cells[j];
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
  }
  /**
   * Helper method to create an ability score table
   * @param headers - Array of header strings
   * @param dataRows - Array of row strings to process
   * @returns HTMLTableElement with formatted ability scores
   */
  createAbilityTable(headers, dataRows) {
    const table = document.createElement("table");
    table.className = "ability-table";
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    for (const header of headers) {
      const th = document.createElement("th");
      th.textContent = header;
      headerRow.appendChild(th);
    }
    thead.appendChild(headerRow);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    for (const rowText of dataRows) {
      const tr = document.createElement("tr");
      const cells = rowText.split("|").filter((_, idx, arr) => idx > 0 && idx < arr.length - 1).map((cell) => cell.trim());
      console.log("Row cells:", cells);
      for (let j = 0; j < cells.length; j++) {
        const td = document.createElement("td");
        if (j === 0) {
          td.className = "ability-name";
        }
        td.textContent = cells[j];
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
  }
  /**
   * Process monster stats with enhanced formatting and compact spacing
   * @param statName - The name of the stat (e.g., "Skills", "Senses")
   * @param statValue - The value of the stat
   * @param container - The container to add the stat to
   */
  createStatItem(statName, statValue, container) {
    const statEl = document.createElement("div");
    statEl.className = "monster-stat-item";
    const statKey = statName.toLowerCase();
    if (statKey.includes("initiative")) {
      statEl.classList.add("stat-initiative");
    } else if (statKey === "skills") {
      statEl.classList.add("stat-skills");
    } else if (statKey === "senses") {
      statEl.classList.add("stat-senses");
    } else if (statKey === "languages") {
      statEl.classList.add("stat-languages");
    }
    const isLongContent = this.longStatKeys.some((key) => statKey.includes(key));
    if (isLongContent) {
      statEl.classList.add("long-content");
    }
    const statLabel = document.createElement("strong");
    statLabel.textContent = statName + ":";
    statEl.appendChild(statLabel);
    statEl.appendChild(document.createTextNode(" " + statValue));
    container.appendChild(statEl);
  }
  /**
   * Enhanced method to process stats and create more compact layout
   * @param lines - The lines to process for stats
   * @param startLine - The line to start processing from
   * @param leftStatsContainer - Container for left stats
   * @param rightStatsContainer - Container for right stats
   * @param additionalStatsContainer - Container for additional stats
   * @returns [currentLine, hasAdditionalStats] - The current line after processing and whether additional stats were found
   */
  processStats(lines, startLine, leftStatsContainer, rightStatsContainer, additionalStatsContainer) {
    let currentLine = startLine;
    let hasAdditionalStats = false;
    const leftStats = ["AC", "HP", "Speed"];
    const rightStats = ["Initiative"];
    while (currentLine < lines.length) {
      const line = lines[currentLine].trim();
      if (line.startsWith("###") || line === "{{tables" || line === "{!tables") {
        break;
      }
      if (line.includes("::")) {
        const parts = line.split("::").map((part) => part.trim());
        if (parts.length === 2) {
          const statName = parts[0].replace(/\*\*/g, "").trim();
          const statValue = parts[1].trim();
          const statKey = statName.toLowerCase();
          if (leftStats.some((s) => statKey.includes(s.toLowerCase()))) {
            this.createStatItem(statName, statValue, leftStatsContainer);
          } else if (rightStats.some((s) => statKey.includes(s.toLowerCase()))) {
            this.createStatItem(statName, statValue, rightStatsContainer);
          } else {
            this.createStatItem(statName, statValue, additionalStatsContainer);
            hasAdditionalStats = true;
          }
        }
      }
      currentLine++;
    }
    return [currentLine, hasAdditionalStats];
  }
  /**
   * Completely restructured renderMonsterContent to achieve the desired layout
   */
  async renderMonsterContent(source, container, formatOptions = { wide: false }) {
    const monster = document.createElement("div");
    monster.className = "monster";
    if (formatOptions.wide) {
      monster.classList.add("monster-wide");
    }
    const lines = source.split("\n");
    let title = "Monster";
    let type = "";
    let currentLine = 0;
    for (let i2 = 0; i2 < lines.length; i2++) {
      if (lines[i2].trim().startsWith("##")) {
        title = lines[i2].replace(/^##\s*/, "").trim();
        currentLine = i2 + 1;
        break;
      }
    }
    if (currentLine < lines.length && lines[currentLine].trim().startsWith("*")) {
      type = lines[currentLine].replace(/^\*|\*$/g, "").trim();
      currentLine++;
    }
    const titleEl = document.createElement("h2");
    titleEl.className = "monster-title";
    titleEl.textContent = title;
    monster.appendChild(titleEl);
    if (type) {
      const typeEl = document.createElement("p");
      typeEl.className = "monster-type";
      typeEl.textContent = type;
      monster.appendChild(typeEl);
    }
    let columnsContainer = null;
    let leftColumn = null;
    let rightColumn = null;
    if (formatOptions.wide) {
      columnsContainer = document.createElement("div");
      columnsContainer.className = "monster-columns";
      monster.appendChild(columnsContainer);
      leftColumn = document.createElement("div");
      leftColumn.className = "monster-left-column";
      columnsContainer.appendChild(leftColumn);
      rightColumn = document.createElement("div");
      rightColumn.className = "monster-right-column";
      columnsContainer.appendChild(rightColumn);
    }
    const statsEl = document.createElement("div");
    statsEl.className = "monster-stats";
    const leftStatsEl = document.createElement("div");
    leftStatsEl.className = "monster-left-stats";
    statsEl.appendChild(leftStatsEl);
    const rightStatsEl = document.createElement("div");
    rightStatsEl.className = "monster-right-stats";
    statsEl.appendChild(rightStatsEl);
    const tablesContainer = document.createElement("div");
    tablesContainer.className = "monster-tables";
    const additionalStatsEl = document.createElement("div");
    additionalStatsEl.className = "monster-additional-stats";
    let sections = [];
    let currentSection = "";
    let currentSectionTitle = "";
    let inTables = false;
    let tableParts = [];
    let hasAdditionalStats = false;
    const leftStats = ["AC", "HP", "Speed"];
    const rightStats = ["Initiative"];
    let i = currentLine;
    while (i < lines.length) {
      const line = lines[i].trim();
      if (line.startsWith("###")) {
        if (currentSectionTitle) {
          sections.push({
            title: currentSectionTitle,
            content: currentSection.trim()
            // Trim to remove extra whitespace
          });
        }
        currentSectionTitle = line.replace(/^###\s*/, "").trim();
        currentSection = "";
        i++;
      } else if (line === "{{tables" || line === "{!tables") {
        inTables = true;
        i++;
      } else if ((line === "}}" || line === "}!") && inTables) {
        inTables = false;
        if (tableParts.length > 0) {
          if (formatOptions.wide) {
            this.processTableDataForWideFormat(tableParts.join("\n"), tablesContainer);
          } else {
            this.processTableData(tableParts.join("\n"), tablesContainer);
          }
          tableParts = [];
        }
        i++;
      } else if (inTables) {
        tableParts.push(line);
        i++;
      } else if (line.includes("::") && !currentSectionTitle) {
        const [newLine, hasAddStats] = this.processStats(
          lines,
          i,
          leftStatsEl,
          rightStatsEl,
          additionalStatsEl
        );
        hasAdditionalStats = hasAdditionalStats || hasAddStats;
        i = newLine;
      } else if (currentSectionTitle && !line.startsWith("{{") && !line.startsWith("}}")) {
        currentSection += line + "\n";
        i++;
      } else {
        i++;
      }
    }
    if (currentSectionTitle) {
      sections.push({
        title: currentSectionTitle,
        content: currentSection.trim()
      });
    }
    if (formatOptions.wide && leftColumn && rightColumn) {
      leftColumn.appendChild(statsEl);
      if (tablesContainer.children.length > 0) {
        leftColumn.appendChild(tablesContainer);
      }
      if (hasAdditionalStats) {
        leftColumn.appendChild(additionalStatsEl);
      }
      this.distributeSectionsForWideFormat(sections, leftColumn, rightColumn);
    } else {
      monster.appendChild(statsEl);
      if (tablesContainer.children.length > 0) {
        monster.appendChild(tablesContainer);
      }
      if (hasAdditionalStats) {
        monster.appendChild(additionalStatsEl);
      }
      for (const section of sections) {
        await this.addSectionToMonster(monster, section.title, section.content);
      }
    }
    container.appendChild(monster);
  }
  /**
   * Add a section directly to an element (for wide format)
   */
  async addSectionToElement(element, title, content) {
    const sectionEl = document.createElement("div");
    sectionEl.className = "monster-section";
    const sectionTitleEl = document.createElement("h3");
    sectionTitleEl.className = "monster-section-title";
    sectionTitleEl.textContent = title;
    sectionEl.appendChild(sectionTitleEl);
    const sectionContentEl = document.createElement("div");
    await import_obsidian.MarkdownRenderer.renderMarkdown(
      content,
      sectionContentEl,
      "",
      this
    );
    sectionEl.appendChild(sectionContentEl);
    element.appendChild(sectionEl);
  }
  /**
   * Add a section to the monster block
   */
  async addSectionToMonster(monster, title, content) {
    const sectionEl = document.createElement("div");
    sectionEl.className = "monster-section";
    const sectionTitleEl = document.createElement("h3");
    sectionTitleEl.className = "monster-section-title";
    sectionTitleEl.textContent = title;
    sectionEl.appendChild(sectionTitleEl);
    const sectionContentEl = document.createElement("div");
    await import_obsidian.MarkdownRenderer.renderMarkdown(
      content,
      sectionContentEl,
      "",
      this
    );
    sectionEl.appendChild(sectionContentEl);
    monster.appendChild(sectionEl);
  }
  /**
   * Process markdown table data into HTML tables
   */
  processTableData(tableContent, container) {
    try {
      const tables = tableContent.split("\n\n").filter((table) => table.trim());
      for (const tableText of tables) {
        const rows = tableText.split("\n").filter((row) => row.trim());
        const tableEl = document.createElement("table");
        tableEl.className = "monster-table";
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (i === 1 && row.includes(":-")) {
            continue;
          }
          const cells = row.split("|").filter((_, idx, arr) => idx > 0 && idx < arr.length - 1).map((cell) => cell.trim());
          const rowEl = document.createElement("tr");
          if (i === 0) {
            for (const cell of cells) {
              const thEl = document.createElement("th");
              thEl.textContent = cell;
              rowEl.appendChild(thEl);
            }
          } else {
            for (const cell of cells) {
              const tdEl = document.createElement("td");
              tdEl.textContent = cell;
              rowEl.appendChild(tdEl);
            }
          }
          tableEl.appendChild(rowEl);
        }
        container.appendChild(tableEl);
      }
    } catch (error) {
      console.error("Error processing table data:", error);
      const errorEl = document.createElement("div");
      errorEl.textContent = "Error processing table: " + error.message;
      errorEl.style.color = "red";
      container.appendChild(errorEl);
    }
  }
};
